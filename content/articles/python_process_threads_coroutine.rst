白话Python 进程，线程，协程
=========================================================

:date: 2014-10-19
:author: SunisDown
:categories: python
:tags: process, thread, coroutine, python
:comments:

Python被人诟病最多的大概就是性能差，在这里讲一下 Python
的多进程，多线程与协程。首先声明这不是教程，看完这篇文章，大概能够对
Python 的多进程与多线程有一定的了解。


.. image:: images/process_thread.png

进程
^^^^

进程是正则执行的程序实例。执行程序的过程中，内核会讲程序代码载入虚拟内存，喂程序变量分配空间，建立bookkeeping 数据结构，来记录与进程有关的信息，比如进程 ID，用户 ID 等

创建进程的时候，内核会为进程分配一定的资源，并在进程存活的时候不断进行调整，比如内存，进程创建的时候会占有一部分内存。进程结束的时候资源会释放出来，来让其他资源使用。

我们可以把进程理解为一种容器，容器内的资源可多可少，但是在容器内的程序只能使用容器内的东西。

线程
^^^^

UNIX
中，一个进程中可以执行多个线程。多个线程共享进程内的资源。所以可以将线程可以看成是共享同一虚拟内存以及其他属性的进程。

线程相对于进程的优势在于同一进程下的不同线程之间的数据共享更加容易。

Python被诟病最多的大概就是解释器全局锁（GIL）了，GIL 的存在是为了实现Python 中对于共享资源访问的互斥。而且是非常霸道的解释器级别的互斥。在GIL的机制下，一个线程访问解释器之后，其他的线程就需要等待这个线程释放之后才可以访问。这种处理方法在单处理器下面并没有什么问题，单处理器的本质是无法并行的。但是再多处理器下面，这种方法会导致无法利用多核的优势。

Python
的线程调度跟操作系统的进程调度类似，都属于抢占式的调度。一个进程执行了一定时间之后，发出一个信号，操作系统响应这个时钟中断（信号），开始进程调度。而在
Python 中，则通过软件模拟这种中断，来实现线程调度。

协程
^^^^

协程我们可以看成是一种用户空间的线程,协程是主动的协作是工作，现有的操作系统线程调度是抢占式。两种的区别在于协作是调度，需要之前的任务主动放弃时间片。

总结
^^^^

在 Python中，使用协程来做并发是对于系统资源消耗最小，可以最大化的做高并发，但是，需要我们自己来做调度，操作系统不会主动调度任务。

