<!doctype html>
<html lang="zh" itemscope itemtype="http://schema.org/Person">
<head>
  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>Python 之 GIL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="sunisdown">

  <link rel="shortcut icon" href="">

  <!-- schema.org -->
  <meta itemprop="name" content="SunisDown">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="">

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
  <!-- Style Meta Data -->
  <link rel="stylesheet" href="http://sunisdown.me/theme/css/style.css" type="text/css" />
  <link rel="stylesheet" href="http://sunisdown.me/theme/css/pygments.css" type="text/css" />

  <!-- Feed Meta Data -->
    <link href="http://sunisdown.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="SunisDown ATOM Feed" />

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">

<meta name="twitter:creator" content="">
<meta name="twitter:url" content="http://sunisdown.me/python-zhi-gil.html">
<meta name="twitter:title" content="SunisDown ~ Python 之 GIL">
<meta name="twitter:description" content="<p>注: 本篇 Blog 是参照
<a class="reference external" href="http://book.douban.com/subject/3117898/">Python源码剖析</a>过的 Python 源
码,内容算是读书笔记吧,中间还不小心翻错了分支,翻到了3.4版本,不过看起来3.4的 GIL
处理要比2.7的优雅一些.总之,感谢陈孺大神</p>
<div class="section" id="gil">
<h2>什么是 GIL</h2>
<p>GIL(Global Interpreter Lock)
是解释器全局锁,用来互斥线程对于Python虚拟机的使用.</p>
</div>
<div class="section" id="id1">
<h2>为什么用 GIL</h2>
<p>我们知道 Python
的线程调度是由机器来调度的,在线程执行的时候,我们不能决定线程什么时候挂起.假设线程
A与线程 B 都保存在对象
Obj_1,而这种情况下有可能会发生一些比较坑的问题:比如 A 在销毁 Obj_1
的过程中被挂起,而这时候 B 线程开始执行销毁操作,而且正常的将 ...</p></div>">

<!-- Facebook Meta Data -->
<meta property="og:title" content="SunisDown ~ Python 之 GIL" />
<meta property="og:description" content="<p>注: 本篇 Blog 是参照
<a class="reference external" href="http://book.douban.com/subject/3117898/">Python源码剖析</a>过的 Python 源
码,内容算是读书笔记吧,中间还不小心翻错了分支,翻到了3.4版本,不过看起来3.4的 GIL
处理要比2.7的优雅一些.总之,感谢陈孺大神</p>
<div class="section" id="gil">
<h2>什么是 GIL</h2>
<p>GIL(Global Interpreter Lock)
是解释器全局锁,用来互斥线程对于Python虚拟机的使用.</p>
</div>
<div class="section" id="id1">
<h2>为什么用 GIL</h2>
<p>我们知道 Python
的线程调度是由机器来调度的,在线程执行的时候,我们不能决定线程什么时候挂起.假设线程
A与线程 B 都保存在对象
Obj_1,而这种情况下有可能会发生一些比较坑的问题:比如 A 在销毁 Obj_1
的过程中被挂起,而这时候 B 线程开始执行销毁操作,而且正常的将 ...</p></div>" />
<meta property="og:image" content="" />
</head>

<body>
  <!-- Sidebar -->
  <aside>
    <!--<center><a href="http://sunisdown.me"><img id="avatar" src=""></a></center>-->
    <h1>SunisDown</h1>
    <br>


    <nav class="nav">
      <ul class="list-bare">
      
          <li><a class="nav__link" href="/index.html">Blog</a></li>
          <li><a class="nav__link" href="/archives.html">Archives</a></li>
          <li><a class="nav__link" href="/tags.html">Tags</a></li>
         
          <li><a class="nav__link" href="http://sunisdown.me/pages/about.html">About</a></li>
         
      </ul>
    </nav>

    <p class="social">
        <a href="https://github.com/sunisdown" target="_blank" ><img src="http://sunisdown.me/theme/images/icons/github.png"></a>
        <a href="https://twitter.com/SunisD0wn" target="_blank" ><img src="http://sunisdown.me/theme/images/icons/twitter.png"></a>
      <a href="http://sunisdown.me/feeds/all.atom.xml" rel="alternate">
        <img src="http://sunisdown.me/theme/images/icons/rss.png"></a>
    </p>

    <!--
    <h2>Categories</h2>
    <ul class="navbar">
      <li class="active"><a href="http://sunisdown.me/category/articles.html">articles</a></li>
    </ul> 
    -->
  </aside>

  <!-- Content -->
  <article>
<section id="content">
    <article>
        <h2 class="post_title post_detail"><a href="http://sunisdown.me/python-zhi-gil.html" rel="bookmark" title="Permalink to Python 之 GIL">Python 之 GIL</a></h2>
        <div class="entry-content blog-post">
            <p>注: 本篇 Blog 是参照
<a class="reference external" href="http://book.douban.com/subject/3117898/">Python源码剖析</a>过的 Python 源
码,内容算是读书笔记吧,中间还不小心翻错了分支,翻到了3.4版本,不过看起来3.4的 GIL
处理要比2.7的优雅一些.总之,感谢陈孺大神</p>
<div class="section" id="gil">
<h2>什么是 GIL</h2>
<p>GIL(Global Interpreter Lock)
是解释器全局锁,用来互斥线程对于Python虚拟机的使用.</p>
</div>
<div class="section" id="id1">
<h2>为什么用 GIL</h2>
<p>我们知道 Python
的线程调度是由机器来调度的,在线程执行的时候,我们不能决定线程什么时候挂起.假设线程
A与线程 B 都保存在对象
Obj_1,而这种情况下有可能会发生一些比较坑的问题:比如 A 在销毁 Obj_1
的过程中被挂起,而这时候 B 线程开始执行销毁操作,而且正常的将
Obj_1的销毁,内存被回收.这时候B 被挂起,A 接着被挂起之前的状态执行.然后
Obj_1已经木有了...类似与这种坑爹的问题,没有 GIL 的情况下会经常发生.</p>
<p>为了避免上述情况发生,我们就需要在解决多线程访问共享资源的互斥.</p>
</div>
<div class="section" id="id2">
<h2>创建 GIL</h2>
<p>要了解在之前的Blog 中,大概的讲过 Python
中的线程调度是由操作系统来调度的.而 GIL
作为多线程操作的产物,要深入了解也必须要从线程<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Modules/threadmodule.c#L850">Thread</a>模块入手.</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">thread_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;start_new_thread&quot;</span><span class="p">,</span>        <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_start_new_thread</span><span class="p">,</span>
                            <span class="n">METH_VARARGS</span><span class="p">,</span>
                            <span class="n">start_new_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;start_new&quot;</span><span class="p">,</span>               <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_start_new_thread</span><span class="p">,</span>
                            <span class="n">METH_VARARGS</span><span class="p">,</span>
                            <span class="n">start_new_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;allocate_lock&quot;</span><span class="p">,</span>           <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_allocate_lock</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">allocate_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;allocate&quot;</span><span class="p">,</span>                <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_allocate_lock</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">allocate_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;exit_thread&quot;</span><span class="p">,</span>             <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_exit_thread</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">exit_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;exit&quot;</span><span class="p">,</span>                    <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_exit_thread</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">exit_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;interrupt_main&quot;</span><span class="p">,</span>          <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_PyThread_interrupt_main</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">interrupt_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;get_ident&quot;</span><span class="p">,</span>               <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_get_ident</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">get_ident_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;_count&quot;</span><span class="p">,</span>                  <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread__count</span><span class="p">,</span>
     <span class="n">METH_NOARGS</span><span class="p">,</span> <span class="n">_count_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;stack_size&quot;</span><span class="p">,</span>              <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">thread_stack_size</span><span class="p">,</span>
                            <span class="n">METH_VARARGS</span><span class="p">,</span>
                            <span class="n">stack_size_doc</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span>                      <span class="nb">NULL</span><span class="p">}</span>           <span class="cm">/* sentinel */</span>
<span class="p">};</span>
</pre></div>
<p>从 Thread module我们可以看到Python
给我们提供的多线程机制的接口.非常简单,极其精简,类似于<tt class="docutils literal">start_new_thread</tt>跟<tt class="docutils literal">start_new</tt>都是同一个接口.</p>
<p>从上面我们找到创建进程的接口,然后跟踪到<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Modules/threadmodule.c#L648">thread_PyThread_start_new_thread</a>里面,官方的<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Modules/threadmodule.c#L687">注释</a>写的也算到位.</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">thread_PyThread_start_new_thread</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">fargs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">keyw</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bootstate</span> <span class="o">*</span><span class="n">boot</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">ident</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="s">&quot;start_new_thread&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keyw</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyCallable_Check</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;first arg must be callable&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;2nd arg must be a tuple&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keyw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">keyw</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;optional 3rd arg must be a dictionary&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">boot</span> <span class="o">=</span> <span class="n">PyMem_NEW</span><span class="p">(</span><span class="k">struct</span> <span class="n">bootstate</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">boot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
    <span class="n">boot</span><span class="o">-&gt;</span><span class="n">interp</span> <span class="o">=</span> <span class="n">PyThreadState_GET</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">interp</span><span class="p">;</span>
    <span class="n">boot</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">boot</span><span class="o">-&gt;</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">boot</span><span class="o">-&gt;</span><span class="n">keyw</span> <span class="o">=</span> <span class="n">keyw</span><span class="p">;</span>
    <span class="n">boot</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">_PyThreadState_Prealloc</span><span class="p">(</span><span class="n">boot</span><span class="o">-&gt;</span><span class="n">interp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">boot</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyMem_DEL</span><span class="p">(</span><span class="n">boot</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">keyw</span><span class="p">);</span>
    <span class="n">PyEval_InitThreads</span><span class="p">();</span> <span class="cm">/* Start the interpreter&#39;s thread-awareness */</span>
    <span class="n">ident</span> <span class="o">=</span> <span class="n">PyThread_start_new_thread</span><span class="p">(</span><span class="n">t_bootstrap</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">boot</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">ThreadError</span><span class="p">,</span> <span class="s">&quot;can&#39;t start new thread&quot;</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">keyw</span><span class="p">);</span>
        <span class="n">PyThreadState_Clear</span><span class="p">(</span><span class="n">boot</span><span class="o">-&gt;</span><span class="n">tstate</span><span class="p">);</span>
        <span class="n">PyMem_DEL</span><span class="p">(</span><span class="n">boot</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">PyInt_FromLong</span><span class="p">(</span><span class="n">ident</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p><tt class="docutils literal">Start the interpreter's <span class="pre">thread-awareness</span></tt>,让解释器开始准备多线程环境,其实就是初始化多线程环境.这里有一些需要注意的地方,Python
在最开始执行的时候,是<strong>没有创建多线程的数据结构的</strong>,也没有创建
GIL.这样可以避免一些只需要单线程的程序做多余的线程调度.只有当我们执行<tt class="docutils literal">start_new_thread</tt>的时候,才会激活多线程机制,创建
GIL.</p>
<p>我们跟踪<tt class="docutils literal">PyEval_InitThreads()</tt>到<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Python/ceval.c#L249">ceval.c</a>,可以看到创建
GIL 的代码:</p>
<pre class="literal-block">
static PyThread_type_lock interpreter_lock = 0; /* This is the GIL */


PyEval_InitThreads(void)
{
    if (interpreter_lock)
        return;
    interpreter_lock = PyThread_allocate_lock();
    PyThread_acquire_lock(interpreter_lock, 1);
    main_thread = PyThread_get_thread_ident();
}
</pre>
<p>从上面的代码中我们可以看到,在初始化多线程环境的时候,会检测
<tt class="docutils literal">interpreter_lock</tt>
是不是已经创建,如果没有创建,则会用<tt class="docutils literal">PyThread_allocate_lock</tt>
创建<tt class="docutils literal">interpreter_lock</tt>.</p>
</div>
<div class="section" id="id3">
<h2>什么是 GIL</h2>
<p>上面我们跟踪到 GIL 的创建过程,可是 GIL 到底是个什么东西?</p>
<p>从前面的代码中,我们看到是由<tt class="docutils literal">PyThread_allocate_lock</tt>来创建GIL
的,而<tt class="docutils literal">PyThread_allocate_lock</tt>则是针对各个平台来做的具体实现,这里我们看<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Python/thread_pthread.h#L360">Posix标准</a>的实现:</p>
<pre class="literal-block">
PyThread_allocate_lock(void)
{
    pthread_lock *lock;
    int status, error = 0;

    dprintf((&quot;PyThread_allocate_lock called\n&quot;));
    if (!initialized)
        PyThread_init_thread();

    lock = (pthread_lock *) malloc(sizeof(pthread_lock));
    if (lock) {
        memset((void *)lock, '\0', sizeof(pthread_lock));
        lock-&gt;locked = 0;

        status = pthread_mutex_init(&amp;lock-&gt;mut,
                                    pthread_mutexattr_default);
        CHECK_STATUS(&quot;pthread_mutex_init&quot;);

        status = pthread_cond_init(&amp;lock-&gt;lock_released,
                                   pthread_condattr_default);
        CHECK_STATUS(&quot;pthread_cond_init&quot;);

        if (error) {
            free((void *)lock);
            lock = 0;
        }
    }

    dprintf((&quot;PyThread_allocate_lock() -&gt; %p\n&quot;, lock));
    return (PyThread_type_lock) lock;
}
</pre>
<p>先检测是否已经初始化,如果没有,则进行初始化.中间加上 malloc
机制,最后返回一个<tt class="docutils literal">pthread_lock</tt>,这就是我们的 GIL
了,<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Python/thread_pthread.h#L113">线程互斥的锁</a>:</p>
<pre class="literal-block">
typedef struct {
    char             locked; /* 0=unlocked, 1=locked */
    /* a &lt;cond, mutex&gt; pair to handle an acquire of a locked lock */
    pthread_cond_t   lock_released;
    pthread_mutex_t  mut;
} pthread_lock;
</pre>
</div>
<div class="section" id="id4">
<h2>什么时候释放 GIL</h2>
<p>总算回到最初我写这篇 Blog
的动机上面来了,我是在去豆瓣面试的时候被问了这个问题,一时语塞,瞎扯一通之后回来决定要好好看一下代码的...
现在都已经快准备入职豆瓣了,才来动手写 Blog,也算是拖延症晚期吧.</p>
<p>在通过 <tt class="docutils literal">PyThread_allocate_lock</tt> 创建 GIL
之后,多线程的开始正常的调度,包括<tt class="docutils literal">sys.getcheckinterval()</tt>
拿到的<tt class="docutils literal">interval</tt>(默认为100)的间隔被动放弃 GIL,或者线程阻塞放弃
GIL.总之,`PyEval_InitThreads
会通过<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Python/ceval.c#L254">PyThread_acquire_lock</a>
来获取 GIL.</p>
</div>

        </div>
        <div class="post_list">
            <span>By </span>
            <a href="http://sunisdown.me/author/sunisdown.html">@Sunisdown</a>
            <span> in </span>
            <span class="post_category"><a href="http://sunisdown.me/category/articles.html" rel="bookmark" title="Permalink to articles">[ articles ]</a></span>
            <span class="post_date">Tue 03 February 2015</span>
            <div><span>Tags : </span>
                <span><a href="http://sunisdown.me/tag/python.html">#Python, </a></span>
                <span><a href="http://sunisdown.me/tag/gil.html">#GIL, </a></span>
            </div>

            <div class="entry-social">
                <span class="twitter"><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=http://sunisdown.me/python-zhi-gil.html&text=Python 之 GIL&via="><img src="http://sunisdown.me/theme/images/icons/twitter-s.png"></a></span>

                <span class="gplus"><a target="_blank" title="Google +" href="https://plus.google.com/share?url=http://sunisdown.me/python-zhi-gil.html&hl=fr" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="http://sunisdown.me/theme/images/icons/google-s.png"></a></span>

                <span class="facebook"><a target="_blank" title="Facebook" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=500,width=700');return false;" href="https://www.facebook.com/sharer.php?u=http://sunisdown.me/python-zhi-gil.html&t=Python 之 GIL"><img src="http://sunisdown.me/theme/images/icons/facebook-s.png"></a></span>

                <a  target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http://sunisdown.me/python-zhi-gil.html&title=Python 之 GIL" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img src="http://sunisdown.me/theme/images/icons/linkedin-s.png"></a>

                <span class="mail"><a href="mailto:?subject=Python 之 GIL&amp;body=Viens découvrir un article à propos de [Python 之 GIL] sur le site de sunisdown. http://sunisdown.me/python-zhi-gil.html" title="Share by Email" target="_blank"><img src="http://sunisdown.me/theme/images/icons/mail-s.png"></a></span>
            </div>
        </div>
    </article>
</section>
  </article>

  <!-- Footer -->
  <footer>
    <p>
      Blog powered by <a href="http://getpelican.com/">Pelican</a>, 
      which takes great advantage of <a href="http://python.org">Python</a>.
      Theme <a href="https://github.com/parbhat/pelican-blue">Pelican-Blue</a> by <a href="https://parbhatpuri.com/">@parbhat</a>.
    </p>
  </footer>


</body>
</html>